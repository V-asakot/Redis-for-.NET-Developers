<h1>Hands-On with Object Insertion with Redis OM .NET</h1>

<p>
    In this Hands-On we'll be exploring how to do object and index modeling with Redis OM.NET.
    You can either create your own project to follow along with and connect a multiplexer,
    or you can open <code>/src/section_2/section5.2/section5.2.csproj</code> in your IDE.
</p>

<h2>The state of our Model</h2>

<p>
    You can observe our model as we left it off in the previous section in <i>Model.cs</i>, practically every field is indexed, 
    and the two types that we are going to insert today are the <code>Employee</code> and <code>Sale</code> types. They each have a
    <code>RedisIdField</code> decorated <code>Id</code> field, that will be used for handling the models id, we'll take a look at what
    that means in a bit. Both classes have a <code>StorageType</code> of JSON, meaning they'll be serialized as JSON as they are inserted
    into Redis. The primary difference in the way they are decorated is that the <code>Employee</code> class sets what it's index name 
    is, and tells Redis OM what prefixes it's allowed to use when indexing. The <code>Sale</code> class on the other hand allows Redis
    OM to use it's defaults.
</p>

<h2>A Simple Insertion</h2>

<p>
    Inserting an object into Redis OM is simple, you use the <code>IRedisCollection&lt;T&gt;.Insert</code> method. You grab a handle to 
    <code>IRedisCollection&lt;T&gt;</code> by using the <code>RedisCollection&lt;T&gt;</code>, then it's as simple as inserting your objects:
    let's try to insert an employee.
</p>

<code>
    var employees = provider.RedisCollection<Employee>();
    var employee = new Employee
    {
        Name = "Steve",
        Address = new Address
        {
            StreetAddress = "Main Street",
            PostalCode = "34739",
            Location = new GeoLoc(-81.006, 27.872)
        },
        Sales = new List<string>()
    };
    var key = employees.Insert(employee);
</code>

<p>
    Notice how we did not initialize an Id for this employee before we inserted it. If an Id is not provided, one will automatically be
    generated by Redis OM, by default, this will be a <a href="https://github.com/ulid/spec"><i>ULID</i></a> - which is essentially a sortable UUID.
    This will be bound directly to the Id Field in the model. Additionally, when you user Insert, it will respond with a key name, which is
    the prefix for the model with the Id added to the end, you can observe these behaviors by simply printing out the key and the id that 
    was generated by the insertion:
</p>

<code>
    Console.WriteLine($"Employee Id: {employee.Id}");
    Console.WriteLine($"Key Name: {key}");
</code>

<p>
    A sample output for this would be:
</p>

<code>
    Employee Id: 01GKMARM1N59CWSVKN4DPV9A6T
    Key Name: Employee:01GKMARM1N59CWSVKN4DPV9A6T
</code>

<p>
    Now let's do something slightly different, lets insert a <code>Sale</code> into redis, but this time we will use the 
    <code>IRedisConnection.Set</code> method, and instead of having Redis OM generate an ID for us, we'll generate one ourself.
</p>

<code>
    var sale = new Sale
    {
        Id = Guid.NewGuid().ToString(),
        Address = new Address
        {
            StreetAddress = "Pinewood Ave",
            PostalCode = "10001",
            Location = new GeoLoc( -73.991, 40.753)
        },
        EmployeeId = employee.Id,
        Total = 5000,
    };

    key = provider.Connection.Set(sale, TimeSpan.FromMinutes(5));
    Console.WriteLine($"Sale Id: {sale.Id}");
    Console.WriteLine($"Key Name: {key}");
</code>

<p>
    This operates very similarly to how the <code>Insert</code> method did, with the key difference being that since <code>Sale</code>
    leans on the defaults for Redis OM, it uses the fully qualified class name as the key prefix, since we provided the ID in the form
    of a freshly generated GUID, Redis OM will not try to generate a ULID for you. Finally, since we added a <code>TimeSpan</code> as our
    second argument, we've ensured that after the allotted time (5 minutes), the key will expire automatically and be removed from Redis.
</p>